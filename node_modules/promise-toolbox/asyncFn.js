"use strict";

var identity = require("./_identity");

var isPromise = require("./isPromise");

var toPromise = require("./_resolve");

var noop = Function.prototype;

function step(key, value) {
  var cursor;

  try {
    cursor = this._iterator[key](value);
  } catch (error) {
    this.finally();
    return this._reject(error);
  }

  value = cursor.value;

  if (cursor.done) {
    this.finally();

    this._resolve(value);
  } else {
    this.toPromise(value).then(this.next, this._throw);
  }
}

function AsyncFn(iterator, resolve, reject) {
  this._iterator = iterator;
  this._reject = reject;
  this._resolve = resolve;
  this._throw = step.bind(this, "throw");
  this.next = step.bind(this, "next");
}

AsyncFn.prototype.finally = noop;
AsyncFn.prototype.toPromise = toPromise;

var asyncFn = function asyncFn(generator) {
  return function () {
    var _arguments = arguments,
        _this = this;

    return new Promise(function (resolve, reject) {
      return new AsyncFn(generator.apply(_this, _arguments), resolve, reject).next();
    });
  };
};

function CancelabledAsyncFn(cancelToken) {
  var _this2 = this;

  AsyncFn.apply(this, [].slice.call(arguments, 1));
  this._cancelToken = cancelToken;
  this._onCancel = noop;
  this.finally = cancelToken.addHandler(function (reason) {
    _this2._onCancel(reason);

    return new Promise(function (resolve) {
      _this2.finally = resolve;
    });
  });
}

Object.setPrototypeOf(CancelabledAsyncFn.prototype, Object.getPrototypeOf(AsyncFn.prototype)).toPromise = function (value) {
  var _this3 = this;

  if (Array.isArray(value)) {
    return toPromise(value[0]);
  }

  var cancelToken = this._cancelToken;

  if (cancelToken.requested) {
    return Promise.reject(cancelToken.reason);
  }

  return isPromise(value) ? new Promise(function (resolve, reject) {
    value.then(resolve, reject);
    _this3._onCancel = reject;
  }) : Promise.resolve(value);
};

asyncFn.cancelable = function (generator, getCancelToken) {
  if (getCancelToken === void 0) {
    getCancelToken = identity;
  }

  return function () {
    var _arguments2 = arguments,
        _this4 = this;

    var cancelToken = getCancelToken.apply(this, arguments);

    if (cancelToken.requested) {
      return Promise.reject(cancelToken.reason);
    }

    return new Promise(function (resolve, reject) {
      new CancelabledAsyncFn(cancelToken, generator.apply(_this4, _arguments2), resolve, reject).next();
    });
  };
};

module.exports = asyncFn;