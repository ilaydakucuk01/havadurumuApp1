"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var evalDisposable = require("./_evalDisposable");

var isDisposable = require("./_isDisposable");

var pFinally = require("./_finally");

var setFunctionNameAndLength = require("./_setFunctionNameAndLength");

var wrapApply = require("./wrapApply");

var wrapCall = require("./wrapCall");

var Disposable = function () {
  function Disposable(dispose, value) {
    if (typeof dispose !== "function") {
      throw new Error("dispose must be a function");
    }

    this._dispose = dispose;
    this._value = value;
  }

  var _proto = Disposable.prototype;

  _proto.dispose = function dispose() {
    if (this._dispose === undefined) {
      throw new TypeError("this disposable has already been disposed");
    }

    var d = this._dispose;
    this._dispose = this._value = undefined;
    return d();
  };

  _createClass(Disposable, [{
    key: "value",
    get: function get() {
      if (this._dispose === undefined) {
        throw new TypeError("this disposable has already been disposed");
      }

      return this._value;
    }
  }]);

  return Disposable;
}();

module.exports = Disposable;

Disposable.all = function all(iterable) {
  var disposables = [];

  var dispose = function dispose() {
    var d = disposables;
    disposables = undefined;
    d.forEach(function (disposable) {
      return disposable.dispose();
    });
  };

  var onFulfill = function onFulfill(maybeDisposable) {
    if (disposables === undefined) {
      return isDisposable(maybeDisposable) && maybeDisposable.dispose();
    }

    if (isDisposable(maybeDisposable)) {
      disposables.push(maybeDisposable);
      return maybeDisposable.value;
    }

    return maybeDisposable;
  };

  var onReject = function onReject(error) {
    if (disposables === undefined) {
      return;
    }

    dispose();
    throw error;
  };

  return Promise.all(Array.from(iterable, function (maybeDisposable) {
    return evalDisposable(maybeDisposable).then(onFulfill, onReject);
  })).then(function (values) {
    return new Disposable(dispose, values);
  });
};

var ExitStack = require("./_ExitStack");

Disposable.factory = function (genFn) {
  return setFunctionNameAndLength(function () {
    var gen = genFn.apply(this, arguments);

    var _ExitStack = new ExitStack(),
        dispose = _ExitStack.dispose,
        stack = _ExitStack.value;

    var onEvalDisposable = function onEvalDisposable(value) {
      return isDisposable(value) ? loop(stack.enter(value)) : value;
    };

    var onFulfill = function onFulfill(_ref) {
      var value = _ref.value;
      return evalDisposable(value).then(onEvalDisposable);
    };

    var loop = function loop(value) {
      return wrapCall(gen.next, value, gen).then(onFulfill);
    };

    return loop().then(function (value) {
      return new Disposable(function () {
        return wrapCall(gen.return, undefined, gen).then(dispose);
      }, value);
    }, function (error) {
      var forwardError = function forwardError() {
        throw error;
      };

      return dispose().then(forwardError, forwardError);
    });
  }, genFn.name, genFn.length);
};

var onHandlerFulfill = function onHandlerFulfill(result) {
  var _ExitStack2 = new ExitStack(),
      dispose = _ExitStack2.dispose,
      stack = _ExitStack2.value;

  var onEvalDisposable = function onEvalDisposable(disposable) {
    return loop(stack.enter(disposable));
  };

  var onFulfill = function onFulfill(cursor) {
    return cursor.done ? cursor.value : evalDisposable(cursor.value).then(onEvalDisposable);
  };

  var loop = function loop(value) {
    return wrapCall(result.next, value, result).then(onFulfill);
  };

  return pFinally(loop(), dispose);
};

Disposable.use = function use() {
  var _this = this;

  var nDisposables = arguments.length - 1;

  if (nDisposables < 0) {
    throw new TypeError("Disposable.use expects at least 1 argument");
  }

  var handler = arguments[nDisposables];

  if (nDisposables === 0) {
    return new Promise(function (resolve) {
      return resolve(handler.call(_this));
    }).then(onHandlerFulfill);
  }

  var disposables;
  var spread = !Array.isArray(disposables = arguments[0]);

  if (spread) {
    disposables = Array.prototype.slice.call(arguments, 0, nDisposables);
  } else {
    nDisposables = disposables.length;
  }

  return Disposable.all(disposables).then(function (dAll) {
    return pFinally((spread ? wrapApply : wrapCall)(handler, dAll.value, _this), function () {
      return dAll.dispose();
    });
  });
};