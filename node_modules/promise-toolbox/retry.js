"use strict";

var matchError = require("./_matchError");

var noop = require("./_noop");

var setFunctionNameAndLength = require("./_setFunctionNameAndLength");

function retry(fn, _temp, args) {
  var _this = this;

  var _ref = _temp === void 0 ? {} : _temp,
      delay = _ref.delay,
      delays = _ref.delays,
      _ref$onRetry = _ref.onRetry,
      onRetry = _ref$onRetry === void 0 ? noop : _ref$onRetry,
      retries = _ref.retries,
      tries = _ref.tries,
      when = _ref.when;

  var shouldRetry;

  if (delays !== undefined) {
    if (delay !== undefined || tries !== undefined || retries !== undefined) {
      throw new TypeError("delays is incompatible with delay, tries and retries");
    }

    var iterator = delays[Symbol.iterator]();

    shouldRetry = function shouldRetry() {
      var _iterator$next = iterator.next(),
          done = _iterator$next.done,
          value = _iterator$next.value;

      if (done) {
        return false;
      }

      delay = value;
      return true;
    };
  } else {
    if (tries === undefined) {
      tries = retries !== undefined ? retries + 1 : 10;
    } else if (retries !== undefined) {
      throw new TypeError("retries and tries options are mutually exclusive");
    }

    if (delay === undefined) {
      delay = 1e3;
    }

    shouldRetry = function shouldRetry() {
      return --tries !== 0;
    };
  }

  when = matchError.bind(undefined, when);
  var attemptNumber = 0;

  var sleepResolver = function sleepResolver(resolve) {
    return setTimeout(resolve, delay);
  };

  var sleep = function sleep() {
    return new Promise(sleepResolver);
  };

  var onError = function onError(error) {
    if (error instanceof ErrorContainer) {
      throw error.error;
    }

    if (when(error) && shouldRetry()) {
      var promise = Promise.resolve(onRetry.call({
        arguments: args,
        attemptNumber: attemptNumber++,
        delay,
        fn,
        this: _this
      }, error));

      if (delay !== 0) {
        promise = promise.then(sleep);
      }

      return promise.then(loop);
    }

    throw error;
  };

  var loopResolver = function loopResolver(resolve) {
    return resolve(fn.apply(_this, args));
  };

  var loop = function loop() {
    return new Promise(loopResolver).catch(onError);
  };

  return loop();
}

module.exports = retry;

function ErrorContainer(error) {
  this.error = error;
}

retry.bail = function retryBail(error) {
  throw new ErrorContainer(error);
};

retry.wrap = function retryWrap(fn, options) {
  var getOptions = typeof options !== "function" ? function () {
    return options;
  } : options;
  return setFunctionNameAndLength(function () {
    return retry.call(this, fn, getOptions.apply(this, arguments), Array.from(arguments));
  }, fn.name, fn.length);
};